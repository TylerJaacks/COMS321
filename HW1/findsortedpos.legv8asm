Main:
    // int *addr = 0x0000;
    ADDI X19, XZR, #0
    // int val = 2;
    ADDI X20, XZR, #2
    // int final = 4;
    ADDI X21, XZR, #4

    // a[0] = 1;
    ADDI X9, XZR, #1
    STUR X9, [X19, #0]
    // a[1] = 2;
    ADDI X9, XZR, #2
    STUR X9, [X19, #8]
    // a[2] = 3;
    ADDI X9, XZR, #3
    STUR X9, [X19, #16]
    // a[3] = 4; 
    ADDI X9, XZR, #4
    STUR X9, [X19, #24]

    // FindSortedPos(addr, val, final)
    BL FindSortedPos
    B Done

// Find sorted position: This procedure takes three parameters,
// the address of an array of sorted ints, a value, and the index
// of the last element in the array.  It searches the array for 
// the sorted position of the value and returns that index.
//
// addr -> X19, val -> X20, and final -> X21, and return -> X22
//
// FindSortedPos(addr, val, final):
//  for i from 0 to final
//    if addr[i] >= val
//      break
//  return i
FindSortedPos:
    // int i = 0
    ADD X22, XZR, XZR                
FindSortedPosLoop:
    SUBS X9, X22, X21

//   B.EQ FindSortedPosLoopDone          // break if i == (n - 1)
//   LSL X9, X19, #3                  // X9 = i * 8
//   ADD X0, X0, X9                   // calculate a + i
//   ADD X21, X0, XZR                 // save a + i
//   SUB X1, X1, X19                  // n - i
//   BL find_smallest
//   LSL X0, X0, #3                   // index of smallest times 8
//   ADD X1, X21, X0
//   ADD X0, X21, XZR
//   BL swap
//   LDUR X1, [SP, #16]
//   LDUR X0, [SP, #8]

    PRNT X22

    // i++;
    ADDI X22, X19, #1
    B FindSortedPosLoop
FindSortedPosLoopDone:
//   LDUR LR, [SP, #0]
//   ADDI SP, SP, #24
    BR LR
Done:
    DUMP